from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes

# Gera par de chaves
def GerarParDeChaves():
    private_key = rsa.generate_private_key(
        
                        public_exponent=65537,
                        key_size=3072,
                        backend=default_backend()
    )

    public_key = private_key.public_key()
    return private_key, public_key

# Salva as chaves em arquivos PEM
def CriarArquivoPem(private_key, public_key):
    private_bytes = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    )
    with open('private_key.pem', 'wb') as private_file:
        private_file.write(private_bytes)

    public_bytes = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )
    with open('public_key.pem', 'wb') as public_file:
        public_file.write(public_bytes)
  
# Lê as chaves dos arquivos PEM
def AbreArquivoPem():
    with open('private_key.pem', 'rb') as pf:
        loaded_private_key = serialization.load_pem_private_key(
            pf.read(),
            password=None,
            backend=default_backend()
        )

    with open('public_key.pem', 'rb') as pubf:
        loaded_public_key = serialization.load_pem_public_key(
            pubf.read(),
            backend=default_backend()
        )

    return loaded_private_key, loaded_public_key


# Faz criptografia e descriptografia com OAEP VERIFICAR
def GerarPadding(loaded_public_key, loaded_private_key):
    padding_config = padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None
    )

    plaintext = b'Bob, este eh um segredo. Nao conte para ninguem. Ass: Alice'

    ciphertext = loaded_public_key.encrypt(
        plaintext=plaintext,
        padding=padding_config
    )

    print("Texto cifrado (hex):", ciphertext.hex())
    print("Tamanho:", len(ciphertext), "bytes")
    print("Tamanho:", len(ciphertext)*8, "bits")

    decrypted = loaded_private_key.decrypt(
        ciphertext=ciphertext,
        padding=padding_config
    )

    print("Texto descriptografado:", decrypted.decode())

    # Mostrar que o OAEP gera criptografias diferentes a cada execução
    ciphertexts = [loaded_public_key.encrypt(plaintext, padding_config) for _ in range(3)]
    for i, ct in enumerate(ciphertexts, 1):
        print(f"Texto cifrado {i} (hex):", ct.hex())
        decrypted = loaded_private_key.decrypt(ct, padding=padding_config)
        print(f"Texto descriptografado {i}:", decrypted.decode())
        
# Execução principal
if __name__ == "__main__":
    private_key, public_key = GerarParDeChaves()
    CriarArquivoPem(private_key, public_key)
    loaded_private_key, loaded_public_key = AbreArquivoPem()
    GerarPadding(loaded_public_key, loaded_private_key) 









