import os
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization, hashes, padding as sym_padding
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes


# Envelope digital>
# Devo gerar par de chaves assimetrico ( publica e privada )
# Gerar chave simetrica.
# Gerar mensagem secreta.
# Criptografo a mensagem com a chave Simetrica ( aes ).
# Criptografo a chave Simetrica com a ( chave publica ) de Alice.
# Envio a chave simetrica criptografada pela publica de Alice e a mensagem cifrada com a chave Assimetrica (aes )
# Usa a chave privada de Alice para descriptografar a chave Simetrica e usa para descriptografar a a mensagem.



# Gera par de chaves
def GerarParDeChaves():
    private_key = rsa.generate_private_key(
        
                        public_exponent=65537,
                        key_size=3072,
                        backend=default_backend()
    )

    public_key = private_key.public_key()
    return private_key, public_key

# Salva as chaves em arquivos PEM
def CriarArquivoPem(private_key, public_key):
    private_bytes = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    )
    with open('private_key.pem', 'wb') as private_file:
        private_file.write(private_bytes)

    public_bytes = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )
    with open('public_key.pem', 'wb') as public_file:
        public_file.write(public_bytes)
  
# Lê as chaves dos arquivos PEM
def AbreArquivoPem():
    with open('private_key.pem', 'rb') as pf:
        loaded_private_key = serialization.load_pem_private_key(
            pf.read(),
            password=None,
            backend=default_backend()
        )

    with open('public_key.pem', 'rb') as pubf:
        loaded_public_key = serialization.load_pem_public_key(
            pubf.read(),
            backend=default_backend()
        )

    return loaded_private_key, loaded_public_key

# Envelope aes + rsa
def CifrarEnvelopeDigital(mensagem: bytes, public_key):
    # Gera chave AES 
    chave_aes = os.urandom(32)

    # Gera IV (16 bytes por conta do AES CBC)
    iv = os.urandom(16)

    # Preparar cipher AES-CBC
    cipher = Cipher(algorithms.AES(chave_aes), modes.CBC(iv), backend=default_backend())
    encryptor = cipher.encryptor()

    # Adicionar padding PKCS7 (mensagem precisa ser múltiplo de 16 bytes)
    padder = sym_padding.PKCS7(128).padder()
    padded_data = padder.update(mensagem) + padder.finalize()

    # Cifra mensagem
    mensagem_cifrada = encryptor.update(padded_data) + encryptor.finalize()

    # Cifra chave AES com RSA pública
    chave_aes_cifrada = public_key.encrypt(
        chave_aes,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )

    # Retornar envelope digital
    return {
        "chave_aes_cifrada": chave_aes_cifrada,
        "iv": iv,
        "mensagem_cifrada": mensagem_cifrada
    }


def DecifrarEnvelopeDigital(envelope: dict, private_key):
    # Decifrar chave AES com RSA privada
    chave_aes = private_key.decrypt(
        envelope["chave_aes_cifrada"],
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )

    # Prepara cipher AES-CBC com a chave recuperada
    cipher = Cipher(algorithms.AES(chave_aes), modes.CBC(envelope["iv"]), backend=default_backend())
    decryptor = cipher.decryptor()

    # Decifrar mensagem
    padded_data = decryptor.update(envelope["mensagem_cifrada"]) + decryptor.finalize()

    # Remover padding PKCS7
    unpadder = sym_padding.PKCS7(128).unpadder()
    mensagem = unpadder.update(padded_data) + unpadder.finalize()

    return mensagem


# 
if __name__ == "__main__":
    private_key, public_key = GerarParDeChaves()
    CriarArquivoPem(private_key, public_key)
    loaded_private_key, loaded_public_key = AbreArquivoPem()

    mensagem = b"Mensagem bla bla bla muito chato bla bla bla"
    print("Mensagem original:", mensagem.decode())

    envelope = CifrarEnvelopeDigital(mensagem, loaded_public_key)
    print("\nEnvelope gerado:")
    print(" - Chave AES cifrada (len):", len(envelope["chave_aes_cifrada"]))
    print(" - IV:", envelope["iv"].hex())
    print(" - Mensagem cifrada:", envelope["mensagem_cifrada"].hex()[:60], "...")

    mensagem_decifrada = DecifrarEnvelopeDigital(envelope, loaded_private_key)
    print("\nMensagem decifrada:", mensagem_decifrada.decode())








